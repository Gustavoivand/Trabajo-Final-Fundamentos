\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{listings} % For code formatting
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{mathpazo}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{color}
%\usepackage{minted}
%\usemintedstyle{emacs}
\usepackage{url}
\usepackage{ctable}
\usepackage{float}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{makecell}
\usepackage{hyperref}
\usepackage{comment}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegray},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}



\newcommand{\DNoise}{n_d}

\newcommand{\Est}[1]{\hat{#1}}
\newcommand{\Test}[1]{\expandafter\hat#1}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\begin{document}
\title{\bf{Trabajo final de curso de Fundamentos de la programación 2024-I}}
%{\footnotesize \textsuperscript{*}}

\author{\IEEEauthorblockN{
Delgado, G. (60\%)}
\IEEEauthorblockA{\textit{Escuela de Ciencias de la Computación} \\
\textit{Universidad Nacional de Ingeniería}\\
Lima, Per\'u \\
\texttt{gustavo.delgado.r@uni.pe}}
\and
\IEEEauthorblockN{ 
Mori, J. (40\%)}
\IEEEauthorblockA{\textit{Escuela de Ciencias de la Computación} \\
\textit{Universidad Nacional de Ingeniería}\\
Lima, Perú \\
\texttt{jean.mori.m@uni.pe }}}

\maketitle

\begin{abstract}
El curso de fundamentos de programación ofrecido por la Universidad Nacional de Ingeniería
aborda principalmente la enseñanza de algunos de los conceptos base de programación en el 
lenguaje C++, como la manipulación de archivos binarios, el uso de punteros o la manipulación
de memoria dinámica. Sin embargo, como proyecto final del curso, la plana docente decidió
plantear una serie de problemas desde muy básicos a algunos con cierta complejidad utilizando
el lenguaje de programación python.

Así pues, el presente documento tiene como finalidad exponer los conceptos
investigados para la resolución de los problemas propuestos por los profesores
del curso, así como también dar a conocer los resultados del desarrollo de dichos
problemas.
\vspace{0.2cm}


Índice de términos— Factorial, Máximo común divisor, Clases en Python, Machine Learning.
    
\end{abstract}

\section{Introducci\'on}
Python es un lenguaje de programación versátil y poderoso ampliamente usado
en varios campos, incluyendo la ciencia de datos, desarrollo web y Computación científica.
Uno de los aspectos por los que destaca python es por su simplicidad y su fácil lectura.
Aquí hacemos una simple comparación de códigos entre python y c++:
\\
Python:
\begin{lstlisting}[language=Python,basicstyle=\small,caption=Script de bienvenida en Python]
	print("Hola mundo")
\end{lstlisting}
\vspace{0.2cm}
C++:
\begin{lstlisting}[language=C,basicstyle=\small,caption=Script de bienvenida en C++]
	#include <iostream>
	using namespace std;
	int main(){
		cout<<"Hola mundo";
		return 0;
	}
\end{lstlisting}


\section{Marco Te\'orico}


	\subsection{Función Factorial}
		La función factorial calcula el producto de todos los enteros positivos 
		desde 1 hasta un número entero no negativo dado \(n\). Se denota como \(n!\).
		\[ n! = n \cdot (n-1) \cdot (n-2) \cdot \ldots \cdot 2 \cdot 1 \]
		Por ejemplo:
		\begin{itemize}
			\item \(5! = 5 \cdot 4 \cdot 3 \cdot 2 \cdot 1 = 120\)
			\item \(0! = 1\) (por convención)
		\end{itemize}
		\subsubsection{Definición Recursiva}

			La función factorial se puede definir recursivamente de la siguiente manera:

			\[ n! = \begin{cases}
				1 & \text{si } n = 0 \\
				n \cdot (n-1)! & \text{si } n > 0
			\end{cases} \]
		\subsubsection{Propiedades}

		\begin{itemize}
				\item \(n! > 0\) para todos los enteros no negativos \(n\).
				\item \(0! = 1\) (por convención).
				\item El factorial crece rápidamente: \(n! > n^2\) para \(n\) suficientemente grande.
			\end{itemize}
	\subsection{Algoritmo de Euclides}
		El algoritmo de Euclides se utiliza para encontrar el 
		**máximo común divisor (MCD)** de dos enteros positivos.
		Dados dos números \(a\) y \(b\), el algoritmo procede de la siguiente manera:
		\begin{enumerate}
			\item Realiza divisiones sucesivas:
				\[ a \mod b = R \]
				donde \(R\) es el residuo al dividir \(a\) entre \(b\).
			\item Actualiza los valores:
				\[ a = b \quad \text{y} \quad b = R \]
				Repite los pasos 1 y 2 hasta que \(a \mod b\) sea mayor que 0.
			\item El MCD es igual al valor final de \(b\).
		\end{enumerate}
	\subsection{Clases en Python}
		En Python, las **clases** son como **constructores de objetos** o 
		**plantillas** para crear instancias. Cada objeto creado a partir de
		una clase tiene sus propias **propiedades** (variables) y **métodos** (funciones).
		\subsubsection{title}





\section{Estado del Arte}


\subsection{Transformador Universal}

	\subsection{BERT}



	\subsection{GPT-2}


		\subsubsection{Resultados}



	\subsection{Transformadores dispersos}



	\subsection{XLNet}


\section{Metodolog\'ia}

\section{Experimentaci\'on y resultados}


\section{Conclusiones}

\section{Discusi\'on}

\section{Conclusiones y trabajos futuros}

%\section{Referencias}
\begin{thebibliography}{00}
\bibitem{b1}Matthew E. Peters, Mark Neumann, Mohit Iyyer, 
Matt Gardner,Christopher Clark, Kenton Lee, Luke Zettlemoyer. 
Deep contextualized word representations. NAACL 2018.

\bibitem{b2}Jacob Devlin, Ming-Wei Chang, Kenton Lee, 
Kristina Toutanova. 
BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding (2018). 
Disponible en \href{https://arxiv.org/abs/1810.04805}{https://arxiv.org/abs/1810.04805}.

\end{thebibliography}

\end{document}
